// Generated by CoffeeScript 2.5.1
(function() {
  var $, $log, $output, analyser, autoValue, canvas, ctx, draw, drawList, elem, gain, linearFrequency, linearToLog, logFrequency, osc, slider, text;

  $ = function(id) {
    return document.getElementById(id);
  };

  $output = $('output');

  text = function(str) {
    return document.createTextNode(str);
  };

  elem = function(tag, children) {
    var e;
    e = document.createElement(tag);
    if (children) {
      e.appendChild(children);
    }
    return e;
  };

  slider = function(str, min, max, step, onChange) {
    var container, input, label;
    container = elem('div');
    label = text(str);
    input = elem('input');
    input.setAttribute('type', 'range');
    input.setAttribute('min', min);
    input.setAttribute('max', max);
    input.setAttribute('step', step);
    input.addEventListener('input', onChange);
    container.appendChild(label);
    container.appendChild(input);
    $output.appendChild(container);
    return input;
  };

  drawList = [];

  draw = function(time) {
    var entry, j, len;
    for (j = 0, len = drawList.length; j < len; j++) {
      entry = drawList[j];
      entry();
    }
    return window.requestAnimationFrame(draw);
  };

  window.requestAnimationFrame(draw);

  autoValue = function(onUpdate) {
    var e;
    e = elem('div');
    drawList.push(onUpdate.bind(this, e));
    return $output.appendChild(e);
  };

  canvas = function(width, height, onDraw) {
    var c, cc;
    console.log('canvas was called');
    c = elem('canvas');
    cc = c.getContext('2d');
    c.width = width;
    c.height = height;
    $output.appendChild(c);
    return drawList.push(onDraw.bind(this, cc));
  };

  $log = elem('pre', text('there will be some output'));

  $output.appendChild($log);

  linearFrequency = function(analyser) {
    return function(cc) {
      var arr, ccHeight, ccWidth, db, freqBinCount, height, i, j, nyquistFreq, ref, results, stepFreq, stepWidth, width, x, y;
      freqBinCount = analyser.frequencyBinCount;
      arr = new Uint8Array(freqBinCount);
      analyser.getByteFrequencyData(arr);
      nyquistFreq = ctx.sampleRate / 2; // the highest freq that can be sampled
      stepFreq = nyquistFreq / freqBinCount;
      ccWidth = cc.canvas.width;
      ccHeight = cc.canvas.height;
      cc.clearRect(0, 0, ccWidth, ccHeight);
      stepWidth = ccWidth / freqBinCount;
      results = [];
      for (i = j = 0, ref = freqBinCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        db = arr[i];
        x = i * stepWidth;
        width = stepWidth;
        height = db * ccHeight / 255;
        y = ccHeight - height;
        cc.beginPath();
        cc.rect(x, y, width, height);
        cc.fillStyle = 'black';
        results.push(cc.fill());
      }
      return results;
    };
  };

  linearToLog = function(freq) {
    return Math.log(freq / 2) / Math.log(10);
  };

  logFrequency = function(analyser) {
    return function(cc) {
      var arr, ccHeight, ccWidth, db, freqBinCount, height, i, j, logNyquistFreq, nyquistFreq, ref, ref1, results, stepFreq, width, x, y;
      freqBinCount = analyser.frequencyBinCount;
      arr = new Uint8Array(freqBinCount);
      analyser.getByteFrequencyData(arr);
      nyquistFreq = ctx.sampleRate / 2; // the highest freq that can be sampled
      // $log.innerText = nyquistFreq
      logNyquistFreq = linearToLog(nyquistFreq);
      $log.innerText = logNyquistFreq;
      stepFreq = nyquistFreq / freqBinCount;
      ccWidth = cc.canvas.width;
      ccHeight = cc.canvas.height;
      cc.clearRect(0, 0, ccWidth, ccHeight);
      results = [];
      for (i = j = ref = Math.ceil(2 / stepFreq), ref1 = freqBinCount; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
        db = arr[i] / 255;
        x = linearToLog(i * stepFreq) / logNyquistFreq * ccWidth;
        width = linearToLog((i + 1) * stepFreq) / logNyquistFreq * ccWidth - x;
        height = db * ccHeight;
        y = ccHeight - height;
        cc.beginPath();
        cc.rect(x, y, width, height);
        cc.fillStyle = 'black';
        results.push(cc.fill());
      }
      return results;
    };
  };

  ctx = new AudioContext();

  osc = ctx.createOscillator();

  osc.type = 'sine';

  osc.frequency.value = 440;

  gain = ctx.createGain();

  gain.gain.value = 0.1;

  analyser = ctx.createAnalyser();

  osc.connect(gain);

  gain.connect(analyser);

  analyser.connect(ctx.destination);

  // UI
  slider('Oscillator frequency', 20, 20000, 1, function(e) {
    return osc.frequency.value = e.target.value;
  });

  autoValue(function(el) {
    return el.innerText = osc.frequency.value;
  });

  slider('Gain', 0, 1, 0.1, function(e) {
    return gain.gain.value = e.target.value;
  });

  autoValue(function(el) {
    return el.innerText = gain.gain.value;
  });

  // analyser drawing
  canvas(600, 150, linearFrequency(analyser));

  canvas(600, 150, logFrequency(analyser));

  osc.start();

}).call(this);
